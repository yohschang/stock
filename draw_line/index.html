<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Candlestick Drawing</title>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    :root {
      color-scheme: dark;
    }

    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: #0b1221;
      color: #e6edf3;
    }

    header {
      padding: 16px 20px;
      font-size: 20px;
      font-weight: 700;
      border-bottom: 1px solid #13203a;
      background: radial-gradient(circle at 20% 20%, rgba(45, 212, 191, 0.15), transparent 35%),
        radial-gradient(circle at 80% 10%, rgba(99, 102, 241, 0.15), transparent 35%),
        #0b1221;
    }

    main {
      padding: 20px;
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 16px;
    }

    section.card {
      background: #0f172a;
      border: 1px solid #13203a;
      border-radius: 10px;
      padding: 16px;
      box-shadow: 0 12px 35px rgba(0, 0, 0, 0.35);
    }

    h2,
    h3 {
      margin: 0 0 12px;
      font-weight: 700;
    }

    p {
      margin: 0 0 10px;
      color: #9fb3c8;
    }

    label {
      display: block;
      font-size: 13px;
      margin: 10px 0 6px;
      color: #d6e1f5;
    }

    input[type="number"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #1f2a44;
      background: #0b1428;
      color: #e6edf3;
    }

    button {
      appearance: none;
      border: none;
      cursor: pointer;
      border-radius: 8px;
      padding: 10px 12px;
      font-weight: 600;
      color: #0b1221;
      background: linear-gradient(120deg, #22d3ee, #6366f1);
      box-shadow: 0 10px 30px rgba(99, 102, 241, 0.35);
      transition: transform 120ms ease, box-shadow 160ms ease;
    }

    button.secondary {
      background: #12233f;
      color: #e6edf3;
      box-shadow: none;
      border: 1px solid #1f2a44;
    }

    button.danger {
      background: linear-gradient(120deg, #ef4444, #f97316);
      color: #fff5f5;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 36px rgba(34, 211, 238, 0.35);
    }

    button+button {
      margin-left: 8px;
    }

    #chart {
      width: 100%;
      height: 640px;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
    }

    .muted {
      color: #9fb3c8;
      font-size: 13px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(99, 102, 241, 0.12);
      border: 1px solid rgba(99, 102, 241, 0.3);
      color: #cbd5ff;
      font-size: 12px;
    }

    .tabs {
      display: flex;
      background: #0b1428;
      border: 1px solid #1f2a44;
      border-radius: 8px;
      padding: 4px;
      gap: 4px;
    }

    .tab {
      flex: 1;
      background: transparent;
      border: none;
      color: #9fb3c8;
      padding: 6px;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: none;
    }

    .tab:hover {
      color: #e6edf3;
      background: rgba(255, 255, 255, 0.05);
      transform: none;
      box-shadow: none;
    }

    .tab.active {
      background: #1f2a44;
      color: #22d3ee;
      font-weight: 600;
    }
  </style>
</head>

<body>
  <header>Plotly Candlestick with Editable Trend Lines</header>
  <main>
    <section class="card">
      <h3>Data & line controls</h3>
      <p class="muted">Pull live OHLCV data, then draw, edit, and persist custom lines per ticker.</p>
      <label for="ticker">Ticker</label>
      <input id="ticker" type="text" value="AAPL" style="text-transform:uppercase;" />
      <label for="range">Range</label>
      <select id="range"
        style="width:100%; padding:8px 10px; border-radius:8px; border:1px solid #1f2a44; background:#0b1428; color:#e6edf3;">
        <option value="1mo">1 month</option>
        <option value="3mo">3 months</option>
        <option value="6mo" selected>6 months</option>
        <option value="1y">1 year</option>
      </select>
      <label>Interval</label>
      <div id="interval-tabs" class="tabs">
        <button class="tab active" data-value="1d">1D</button>
        <button class="tab" data-value="1wk">1W</button>
        <button class="tab" data-value="1mo">1M</button>
      </div>
      <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
        <button id="load">Load from Yahoo Finance</button>
        <button id="fit" class="secondary">Zoom to candles</button>
      </div>
      <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
        <button id="regen">Use synthetic data</button>
      </div>
      <div style="margin-top:20px;"><span class="pill" id="mode-pill">Pan / inspect</span></div>
      <p class="muted" style="margin-top:10px;">Select an action below then use the chart's toolbar handles. Drag the
        line's endpoints to edit or clear all lines with one click.</p>
      <div class="toolbar">
        <button id="draw">Draw line</button>
        <button id="edit" class="secondary">Edit lines</button>
        <button id="clear" class="danger">Clear all lines</button>
      </div>
      <label for="extend">Auto-extend</label>
      <select id="extend"
        style="width:100%; padding:8px 10px; border-radius:8px; border:1px solid #1f2a44; background:#0b1428; color:#e6edf3;">
        <option value="none">No extension</option>
        <option value="forward">Extend forward</option>
        <option value="backward">Extend backward</option>
        <option value="both">Extend both directions</option>
      </select>
      <p id="status" class="muted" style="margin-top:12px;">Idle</p>
    </section>
    <section class="card" style="min-width:0;">
      <div id="chart"></div>
      <p class="muted" id="line-count" style="margin-top:10px;">0 custom lines on the canvas.</p>
      <div id="line-list" style="margin-top:16px; display:flex; flex-direction:column; gap:8px;"></div>
      <p class="muted" style="margin-top:8px;">Lines can be drawn anywhere, even outside the candle area. Use the per-line delete buttons or clear all lines at once.</p>
      <div id="debug"
        style="margin-top:20px; background:#000; color:#0f0; font-family:monospace; padding:10px; white-space:pre-wrap; max-height:200px; overflow:auto;">
      </div>
    </section>
  </main>
  <script>
    const chartEl = document.getElementById("chart");
    const statusEl = document.getElementById("status");
    const lineCountEl = document.getElementById("line-count");
    const pillEl = document.getElementById("mode-pill");
    const tickerEl = document.getElementById("ticker");
    const rangeEl = document.getElementById("range");
    const intervalTabs = document.querySelectorAll("#interval-tabs .tab");
    const extendEl = document.getElementById("extend");

    let currentInterval = "1d";

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function setModePill(text) {
      pillEl.textContent = text;
    }

    function withDatePadding(dates, days) {
      const start = new Date(dates[0]);
      start.setDate(start.getDate() - days);
      const end = new Date(dates.at(-1));
      end.setDate(end.getDate() + days);
      return [start, end];
    }

    function findNearestDate(targetDate, dates) {
      if (!dates || dates.length === 0) return targetDate;
      const targetTs = new Date(targetDate).getTime();
      let closest = dates[0];
      let minDiff = Math.abs(targetTs - new Date(dates[0]).getTime());

      for (let i = 1; i < dates.length; i++) {
        const diff = Math.abs(targetTs - new Date(dates[i]).getTime());
        if (diff < minDiff) {
          minDiff = diff;
          closest = dates[i];
        }
      }
      return closest;
    }

    function toISOStringSafe(value) {
      const d = new Date(value);
      return Number.isNaN(d.getTime()) ? value : d.toISOString();
    }

    function toDateSafe(value) {
      const d = new Date(value);
      return Number.isNaN(d.getTime()) ? value : d;
    }

    function toNumberSafe(value) {
      const n = Number(value);
      return Number.isFinite(n) ? n : value;
    }

    function normalizeExtend(value) {
      return ["none", "forward", "backward", "both"].includes(value) ? value : "none";
    }

    const storageKey = "draw_line_shapes_v1";
    let currentTicker = tickerEl.value.toUpperCase();
    let series = null;
    let storedShapes = [];
    let internalUpdate = false;
    let selectedShapeIdx = null;

    const layout = {
      dragmode: "pan",
      margin: { l: 60, r: 20, t: 16, b: 40 },
      plot_bgcolor: "#0b1221",
      paper_bgcolor: "#0b1221",
      xaxis: {
        range: withDatePadding([new Date()], 3),
        showgrid: true,
        gridcolor: "rgba(255,255,255,0.05)",
        zeroline: false,
      },
      yaxis: {
        range: [0, 1],
        showgrid: true,
        gridcolor: "rgba(255,255,255,0.05)",
        zeroline: false,
      },
      newshape: {
        line: { color: "#22d3ee", width: 2 },
        opacity: 0.95,
        layer: "above",
      },
      shapes: [],
      edits: {
        shapePosition: true,
        shapeDimensions: true,
        shapeDelete: true,
      },
      legend: { orientation: "h" },
    };

    const config = {
      responsive: true,
      displaylogo: false,
      modeBarButtonsToAdd: ["drawline"],
      toImageButtonOptions: { format: "png" },
      editable: true,
      edits: {
        shapePosition: true,
        shapeDimensions: true,
        shapeDelete: true,
      },
    };

    const linePalette = [
      "#22d3ee",
      "#c084fc",
      "#f472b6",
      "#f97316",
      "#34d399",
      "#f59e0b",
      "#60a5fa",
    ];

    function randomLineColor() {
      const idx = Math.floor(Math.random() * linePalette.length);
      return linePalette[idx];
    }

    function getDataRange() {
      if (series && Array.isArray(series.dates) && series.dates.length > 0) {
        const times = series.dates
          .map((d) => new Date(d).getTime())
          .filter((t) => Number.isFinite(t));
        if (times.length) {
          const min = Math.min(...times);
          const max = Math.max(...times);
          return [new Date(min), new Date(max)];
        }
      }
      if (layout.xaxis.range && layout.xaxis.range.length === 2) {
        return layout.xaxis.range.map((d) => new Date(d));
      }
      const now = new Date();
      return withDatePadding([now], 3);
    }

    async function fetchYahooSeries(ticker, range, interval) {
      // Use local server API
      const url = `/api/data?ticker=${encodeURIComponent(ticker)}&interval=${encodeURIComponent(interval)}&range=${encodeURIComponent(range)}`;
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error(`Request failed: ${res.status}`);
      }
      const data = await res.json();

      if (!data.dates || data.dates.length === 0) {
        throw new Error("No usable OHLC points returned.");
      }

      const dates = data.dates.map(ts => new Date(ts));
      const o = data.open;
      const h = data.high;
      const l = data.low;
      const c = data.close;

      const padding = (Math.max(...h) - Math.min(...l)) * 0.05 || 1;
      const yMin = Math.min(...l) - padding;
      const yMax = Math.max(...h) + padding;
      return { dates, o, h, l, c, yRange: [yMin, yMax] };
    }

    function generateSeries(count = 120) {
      const now = new Date();
      const dates = [];
      for (let i = count - 1; i >= 0; i -= 1) {
        const d = new Date(now);
        d.setDate(now.getDate() - i);
        dates.push(d);
      }
      let price = 100;
      const o = [], h = [], l = [], c = [];
      for (const day of dates) {
        const change = (Math.random() - 0.45) * 2.5;
        const open = price;
        const close = price + change;
        const high = Math.max(open, close) + Math.random() * 1.5;
        const low = Math.min(open, close) - Math.random() * 1.5;
        o.push(open.toFixed(2));
        h.push(high.toFixed(2));
        l.push(low.toFixed(2));
        c.push(close.toFixed(2));
        price = close;
      }
      const rangePadding = 12;
      const yMin = Math.min(...l) - rangePadding;
      const yMax = Math.max(...h) + rangePadding;
      return { dates, o, h, l, c, yRange: [yMin, yMax] };
    }

    async function saveShapesForTicker(ticker, shapes) {
      // Convert shapes to requested format: [[x0, y0], [x1, y1]]
      const formattedShapes = shapes.map(s => {
        const x0 = toISOStringSafe(s.x0);
        const x1 = toISOStringSafe(s.x1);
        const y0 = toNumberSafe(s.y0);
        const y1 = toNumberSafe(s.y1);
        const extend = normalizeExtend(s.extend || extendEl.value || "none");
        return [
          [x0, y0],
          [x1, y1],
          extend
        ];
      });

      try {
        // Fetch current lines first to merge
        const res = await fetch('/api/lines');
        let data = await res.json();
        if (!Array.isArray(data) || data.length === 0) {
          data = [{}];
        }

        // Update ticker data
        data[0][ticker] = formattedShapes;

        // Save back
        await fetch('/api/lines', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
      } catch (e) {
        console.error("Failed to save lines:", e);
      }
    }

    async function loadShapesForTicker(ticker) {
      try {
        const res = await fetch('/api/lines');
        const data = await res.json();
        if (!Array.isArray(data) || data.length === 0 || !data[0][ticker]) {
          return [];
        }

        // Convert back to Plotly shapes
        // [[x0, y0], [x1, y1]] -> { x0, x1, y0, y1, type: 'line', ... }
        return data[0][ticker].map(pair => {
          const [[rawX0, rawY0], [rawX1, rawY1], rawExtend] = pair;
          return {
            x0: toDateSafe(rawX0),
            y0: toNumberSafe(rawY0),
            x1: toDateSafe(rawX1),
            y1: toNumberSafe(rawY1),
            type: 'line',
            color: randomLineColor(),
            extend: normalizeExtend(rawExtend || extendEl.value),
            saved: true,
          };
        });
      } catch (e) {
        console.error("Failed to load lines:", e);
        return [];
      }
    }

    function extendCoords(shape) {
      const extend = shape.extend || "none";
      if (extend === "none") return shape;
      const range = getDataRange();
      const [xStartRaw, xEndRaw] = range;
      const xStart = new Date(xStartRaw).getTime();
      const xEnd = new Date(xEndRaw).getTime();
      const x0 = new Date(shape.x0).getTime();
      const x1 = new Date(shape.x1).getTime();
      if (!Number.isFinite(x0) || !Number.isFinite(x1) || x0 === x1) {
        return shape; // keep vertical or invalid as-is
      }
      const slope = (shape.y1 - shape.y0) / (x1 - x0);
      const forward = () => ({
        x1: new Date(xEnd),
        y1: shape.y0 + slope * (xEnd - x0),
      });
      const backward = () => ({
        x0: new Date(xStart),
        y0: shape.y1 - slope * (x1 - xStart),
      });
      if (extend === "forward") {
        const f = forward();
        return { ...shape, ...f };
      }
      if (extend === "backward") {
        const b = backward();
        return { ...shape, ...b };
      }
      const f = forward();
      const b = backward();
      return { ...shape, ...f, ...b };
    }

    function applyShapes() {
      const extended = storedShapes.map((s, idx) => {
        const isSelected = idx === selectedShapeIdx;
        const base = {
          type: "line",
          x0: s.x0,
          x1: s.x1,
          y0: s.y0,
          y1: s.y1,
          line: {
            color: isSelected ? "#ffffff" : (s.color || layout.newshape.line.color || "#22d3ee"),
            width: isSelected ? 4 : 2,
            dash: isSelected ? "dot" : "solid"
          },
          opacity: 0.95,
          layer: "above",
          meta: { extend: s.extend || extendEl.value },
          extend: s.extend || extendEl.value,
        };
        return extendCoords(base);
      });
      internalUpdate = true;
      Plotly.relayout(chartEl, { shapes: extended }).then(() => {
        internalUpdate = false;
        updateLineCount();
      });
    }

    const debugEl = document.getElementById("debug");
    function logToDebug(msg) {
      if (debugEl) {
        debugEl.textContent += msg + "\n";
        debugEl.scrollTop = debugEl.scrollHeight;
      }
      // Send to server
      fetch('/debug_log', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ msg: msg, timestamp: Date.now() })
      }).catch(e => console.error("Failed to send log", e));
    }

    function syncStoredShapes(eventData) {
      let shapes = chartEl.layout?.shapes || chartEl._fullLayout?.shapes || [];

      logToDebug(`Sync: layout.shapes=${shapes ? shapes.length : 'null'}, eventData=${eventData ? JSON.stringify(Object.keys(eventData)) : 'null'}`);

      // Fallback: if shapes is empty but eventData has shapes, try to use eventData
      if ((!shapes || shapes.length === 0) && eventData) {
        if (eventData.shapes && Array.isArray(eventData.shapes)) {
          shapes = eventData.shapes;
          logToDebug("Fallback: used full array from eventData");
        } else {
          // Check for new shape object like "shapes[0]": {...}
          const shapeKeys = Object.keys(eventData).filter(k => k.match(/^shapes\[\d+\]$/));
          if (shapeKeys.length > 0) {
            logToDebug(`Fallback: found partial keys: ${JSON.stringify(shapeKeys)}`);
            const tempShapes = [];
            shapeKeys.forEach(k => {
              const match = k.match(/shapes\[(\d+)\]$/);
              if (match) {
                const idx = parseInt(match[1]);
                tempShapes[idx] = eventData[k];
              }
            });
            if (tempShapes.length > 0) {
              shapes = tempShapes.filter(s => s);
              logToDebug(`Fallback: reconstructed ${shapes.length} shapes`);
            }
          }
        }
      }

      logToDebug(`Final shapes count: ${shapes.length}`);

      const previousShapes = storedShapes;
      const previousCount = previousShapes.length;
      storedShapes = shapes.map((s, idx) => {
        const x0 = toDateSafe(s.x0);
        const x1 = toDateSafe(s.x1);
        const y0 = toNumberSafe(s.y0);
        const y1 = toNumberSafe(s.y1);
        const extend = normalizeExtend(s.meta?.extend || s.extend || extendEl.value);
        const color = s.line?.color || (idx >= previousCount ? randomLineColor() : previousShapes[idx]?.color || randomLineColor());
        const prev = previousShapes[idx];
        const unchanged = prev
          && new Date(prev.x0).getTime() === new Date(x0).getTime()
          && new Date(prev.x1).getTime() === new Date(x1).getTime()
          && prev.y0 === y0
          && prev.y1 === y1
          && prev.extend === extend;
        const saved = prev ? (prev.saved && unchanged) : false;
        return { x0, x1, y0, y1, extend, color, saved };
      });
      updateLineCount();
    }

    function persistSavedShapes() {
      const savedShapes = storedShapes.filter(s => s.saved);
      saveShapesForTicker(currentTicker, savedShapes);
    }

    function renderPlot() {
      const candle = {
        type: "candlestick",
        x: series.dates,
        open: series.o,
        high: series.h,
        low: series.l,
        close: series.c,
        decreasing: { line: { color: "#f87171" }, fillcolor: "#b91c1c" },
        increasing: { line: { color: "#34d399" }, fillcolor: "#065f46" },
        name: currentTicker,
      };
      Plotly.newPlot(chartEl, [candle], layout, config).then(() => {
        chartEl.on("plotly_relayout", (eventData) => {
          if (internalUpdate) return;
          // Pass eventData to syncStoredShapes
          syncStoredShapes(eventData);
        });

        chartEl.on("plotly_afterplot", () => {
          if (internalUpdate) return;
          syncStoredShapes();
        });
        applyShapes();

        // Add click listener for selection
      });
    }

    function renderLineList() {
      const listEl = document.getElementById("line-list");
      listEl.innerHTML = "";

      storedShapes.forEach((s, idx) => {
        const item = document.createElement("div");
        const isSelected = idx === selectedShapeIdx;
        item.style.cssText = `
          display:flex; align-items:center; gap:8px;
          background:${isSelected ? "#14203a" : "#0f172a"};
          padding:8px 12px; border-radius:6px;
          border:1px solid ${isSelected ? "#22d3ee" : "#1f2a44"};
          cursor:pointer;
        `;
        item.onclick = () => {
          selectedShapeIdx = isSelected ? null : idx;
          applyShapes();
          renderLineList();
          setStatus(selectedShapeIdx === null ? "Deselected line." : `Selected line ${idx + 1}.`);
        };

        const info = document.createElement("span");
        info.style.fontSize = "13px";
        info.style.color = "#cbd5ff";
        const d1 = new Date(s.x0).toLocaleDateString();
        const d2 = new Date(s.x1).toLocaleDateString();
        info.textContent = `Line ${idx + 1}: ${d1} â†’ ${d2}`;

        const extendSelect = document.createElement("select");
        extendSelect.style.cssText = "margin-left:auto; padding:4px 8px; border-radius:6px; border:1px solid #1f2a44; background:#0b1428; color:#e6edf3;";
        ["none", "forward", "backward", "both"].forEach(val => {
          const opt = document.createElement("option");
          opt.value = val;
          opt.textContent = val === "none" ? "No extend" : `Extend ${val}`;
          if (s.extend === val) opt.selected = true;
          extendSelect.appendChild(opt);
        });
        extendSelect.onclick = (e) => e.stopPropagation();
        extendSelect.onchange = (e) => {
          e.stopPropagation();
          storedShapes[idx].extend = extendSelect.value;
          storedShapes[idx].saved = false;
          applyShapes();
          renderLineList();
        };

        const saveBtn = document.createElement("button");
        saveBtn.textContent = s.saved ? "Saved" : "Save";
        saveBtn.className = "secondary";
        saveBtn.style.cssText = "padding:4px 10px; font-size:12px;";
        saveBtn.disabled = !!s.saved;
        saveBtn.onclick = (e) => {
          e.stopPropagation();
          storedShapes[idx].saved = true;
          persistSavedShapes();
          renderLineList();
          setStatus(`Line ${idx + 1} saved.`);
        };

        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.className = "danger";
        delBtn.style.cssText = "padding:4px 8px; font-size:12px; margin-left:12px;";
        delBtn.onclick = (e) => {
          e.stopPropagation();
          storedShapes.splice(idx, 1);
          persistSavedShapes();
          applyShapes();
          renderLineList();
        };

        item.appendChild(info);
        item.appendChild(extendSelect);
        item.appendChild(saveBtn);
        item.appendChild(delBtn);
        listEl.appendChild(item);
      });
    }

    function updateLineCount() {
      const shapeCount = (chartEl.layout?.shapes || []).length;
      lineCountEl.textContent = `${shapeCount} custom line${shapeCount === 1 ? "" : "s"} on the canvas.`;
      renderLineList();
    }

    function setDragMode(mode, label) {
      Plotly.relayout(chartEl, { dragmode: mode });
      setModePill(label);
    }

    document.getElementById("draw").addEventListener("click", () => {
      const color = randomLineColor();
      setStatus(`Drawing mode: new lines will use color ${color}. Click and drag on the chart to place a line.`);
      Plotly.relayout(chartEl, { "newshape.line.color": color });
      setDragMode("drawline", "Draw line");
    });

    document.getElementById("edit").addEventListener("click", () => {
      setStatus("Edit mode: drag line endpoints or move the full line.");
      setDragMode("pan", "Edit lines");
    });

    document.getElementById("clear").addEventListener("click", () => {
      storedShapes = [];
      saveShapesForTicker(currentTicker, storedShapes);
      Plotly.relayout(chartEl, { shapes: [] }).then(() => updateLineCount());
      setStatus("All lines cleared.");
      setDragMode("pan", "Pan / inspect");
    });

    document.getElementById("fit").addEventListener("click", () => {
      Plotly.relayout(chartEl, {
        "xaxis.autorange": true,
        "yaxis.autorange": true,
      });
      setStatus("Viewport reset to candle data.");
      setModePill("Pan / inspect");
    });

    document.getElementById("regen").addEventListener("click", () => {
      series = generateSeries(120);
      layout.xaxis.range = withDatePadding(series.dates, 3);
      layout.yaxis.range = series.yRange;
      storedShapes = [];
      saveShapesForTicker(currentTicker, storedShapes);
      renderPlot();
      setStatus(`Generated synthetic candles. Drag lines wherever you like, even outside the price range.`);
      setModePill("Pan / inspect");
    });

    async function loadTickerData() {
      const ticker = tickerEl.value.trim().toUpperCase();
      if (!ticker) return;

      const isSameTicker = currentTicker === ticker;
      currentTicker = ticker;

      setStatus(`Loading ${ticker} from Yahoo Finance...`);
      try {
        // Preserve view range if ticker is same
        const currentXRange = (isSameTicker && chartEl.layout && chartEl.layout.xaxis) ? chartEl.layout.xaxis.range : null;

        series = await fetchYahooSeries(ticker, rangeEl.value, currentInterval);

        if (currentXRange) {
          // Check if current range overlaps with new data
          // If so, keep it. If not (e.g. completely out of bounds), reset.
          // For simplicity, we'll try to keep it if it's valid.
          layout.xaxis.range = currentXRange;
        } else {
          layout.xaxis.range = withDatePadding(series.dates, 3);
        }

        layout.yaxis.range = series.yRange;
        storedShapes = await loadShapesForTicker(currentTicker);
        renderPlot();
        setStatus(`Loaded ${ticker} with ${series.dates.length} candles. Stored lines restored.`);
        setModePill("Pan / inspect");
      } catch (err) {
        console.error(err);
        series = generateSeries(120);
        layout.xaxis.range = withDatePadding(series.dates, 3);
        layout.yaxis.range = series.yRange;
        storedShapes = [];
        renderPlot();
        setStatus(`Failed to load ${ticker}: ${err.message}. Showing synthetic data instead.`);
      }
    }

    document.getElementById("load").addEventListener("click", loadTickerData);
    rangeEl.addEventListener("change", loadTickerData);

    // Handle tab switching
    intervalTabs.forEach(tab => {
      tab.addEventListener("click", () => {
        // Update active class
        intervalTabs.forEach(t => t.classList.remove("active"));
        tab.classList.add("active");

        // Update current interval
        currentInterval = tab.dataset.value;

        // Reload data
        loadTickerData();
      });
    });

    extendEl.addEventListener("change", () => {
      setStatus(`Default extend for new lines: ${extendEl.value}`);
    });

    // initial bootstrap
    loadTickerData();
  </script>
</body>

</html>
